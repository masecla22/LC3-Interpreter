%{
#include "../grammar/parser.h"   /* will be generated by Bison */

static char* inputbuffer;

int linenr = 1;
int colnr = 1;

static void eat() {
  char *s;
  for (s=yytext; *s; s++) {
    if (*s == '\n') {
      linenr++;
      colnr = 0;
    } 
    colnr++;
  }
}

%}

identifier [a-zA-Z_][a-zA-Z0-9_]*

stringzDirective  (?i:\.stringz)[ \t]*(\"[^\"\n]*\"|[^ \t\n]+)

%%

(?i:add)                 {eat(); return ADD;}
(?i:and)                 {eat(); return AND;}
(?i:jmp)                 {eat(); return JMP;}
(?i:jsr)                 {eat(); return JSR;}
(?i:jsrr)                {eat(); return JSRR;}
(?i:ld)                  {eat(); return LD;}
(?i:ldi)                 {eat(); return LDI;}
(?i:ldr)                 {eat(); return LDR;}
(?i:lea)                 {eat(); return LEA;}
(?i:not)                 {eat(); return NOT;}
(?i:ret)                 {eat(); return RET;}
(?i:rti)                 {eat(); return RTI;}
(?i:st)                  {eat(); return ST;}
(?i:sti)                 {eat(); return STI;}
(?i:str)                 {eat(); return STR;}
(?i:trap)                {eat(); return TRAP;}

%{ /* LC-3 Pseudo instructions */ %}
(?i:getc)                {eat(); return GETC;}
(?i:out)                 {eat(); return OUT;}
(?i:puts)                {eat(); return PUTS;}
(?i:putsp)                {eat(); return PUTSP;}
(?i:in)                  {eat(); return IN;}
(?i:halt)                {eat(); return HALT;}

%{ /* 
LC-3 Condition flags 

According to the LC-3 manual, the condition flags are:
    N - Negative
    Z - Zero
    P - Positive

And they can be combined together to form flags, however the order matters.
This assembler will not enforce the order, technically making it a bit more lenient than the LC-3 manual.

*/ %}
(?i:br)                    { eat(); return BR; }
(?i:brp)                   { eat(); return BR_P; }
(?i:brz)                   { eat(); return BR_Z; }
(?i:brn)                   { eat(); return BR_N; }
(?i:br(pz|zp))             { eat(); return BR_PZ; }
(?i:br(pn|np))             { eat(); return BR_PN; }
(?i:br(zn|nz))             { eat(); return BR_ZN; }
(?i:br(pzn|pnz|zpn|znp|nzp|npz)) { eat(); return BR_PZN; }

%{ /* LC-3 Registers */ %}
(?i:r0)                  { eat(); return R0; }
(?i:r1)                  { eat(); return R1; }
(?i:r2)                  { eat(); return R2; }
(?i:r3)                  { eat(); return R3; }
(?i:r4)                  { eat(); return R4; }
(?i:r5)                  { eat(); return R5; }
(?i:r6)                  { eat(); return R6; }
(?i:r7)                  { eat(); return R7; }

%{ /* LC-3 Directives */ %}
(?i:\.orig)               { eat(); return ORIG; }
(?i:\.fill)               { eat(); return FILL; }
(?i:\.blkw)               { eat(); return BLKW; }
(?i:\.end)                { eat(); return END; }

%{ /* LC-3 Comments */ %}
;[^\n]*                   { eat(); /* eat comment */  }
[ \t\r]+                   { eat(); /* whitespace */   }
\n                       { linenr++; colnr = 1; }

%{ /* LC-3 Literals */ %}
[xX](-)?[0-9a-fA-F]+         {eat(); yylval.ival = strtol(yytext+1, NULL, 16); return HEX_LITERAL;}
(#)?(-)?[0-9]+                  {eat(); yylval.ival = strtol(yytext+(yytext[0]=='#'), NULL, 10); return DECIMAL_LITERAL;}

%{ /* LC-3 Identifiers */ %}
{identifier}             {eat(); yylval.sval = strlen(yytext) ? strdup(yytext) : NULL; return IDENTIFIER;}
{stringzDirective}          {
  eat(); 

  char* textPointer = yytext + 8; // Skip the .STRINGZ directive 
  // Eat up all the whitespace
  while (*textPointer == ' ' || *textPointer == '\t') {
    textPointer++;
  }


  int length = strlen(textPointer);

  // Check if the string is enclosed in quotes
  if (*textPointer == '"') {
    // Make sure last character is a quote
    if (textPointer[length-1] == '"') {
      textPointer[length-1] = '\0';
    } else {
      fprintf(stderr, "Stringz directive must be enclosed in quotes in line %d.\n", linenr);
      exit(1);
    }
    textPointer++;
  }

  yylval.sval = strdup(textPointer);
  return STRINGZ;
}


%{ /* LC-3 Special characters */ %}
,                        {eat();  /* ignore commas */ }                    

.           {
              fprintf(stderr, "Unrecognized character '%c' in line %d.\n", *yytext, linenr);
              exit(1);
            }

%%

/**
 * This function initializes the lexer with the file to be read.
 * 
 * @param f The file to be read.
 */
void initLexer(FILE *f) {
  int length;
  fseek (f, 0, SEEK_END);
  length = ftell (f);
  fseek (f, 0, SEEK_SET);
  inputbuffer = malloc (length+1);
  inputbuffer[length]='\0';
  length = fread (inputbuffer, 1, length, f);
  fseek (f, 0, SEEK_SET);
  yyin = f;
}

void finalizeLexer() {
  free(inputbuffer);
  yylex_destroy();
}

void showErrorLine() {
  char *p = inputbuffer;
  int line = linenr;
  while ((*p != '\0') && (line > 1)) {
    line -= (*p == '\n');
    p++;
  }
  fprintf(stderr, "line %2d: ", linenr);

  while ((*p != '\0') && (*p != '\n')) {
    putc(*p != '\t' ? *p : ' ', stderr);
    p++;
  }
  putc('\n', stderr);
  fprintf(stderr, "--------");
  for (int i=colnr-strlen(yytext); i>0; i--) {
    putc('-', stderr);
  }
  fprintf(stderr, "^\n");
}
