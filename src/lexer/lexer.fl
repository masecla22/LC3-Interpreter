%{
#include "../grammar/parser.h"   /* will be generated by Bison */

static char* inputbuffer;
%}

identifier [a-zA-Z_][a-zA-Z0-9_]*

%%

(?i:add)                 {return ADD;}
(?i:and)                {return AND;}
(?i:jmp)                 {return JMP;}
(?i:jsr)                 {return JSR;}
(?i:jsrr)                {return JSRR;}
(?i:ld)                  {return LD;}
(?i:ldi)                 {return LDI;}
(?i:ldr)                 {return LDR;}
(?i:lea)                 {return LEA;}
(?i:not)                 {return NOT;}
(?i:ret)                 {return RET;}
(?i:rti)                 {return RTI;}
(?i:st)                  {return ST;}
(?i:sti)                 {return STI;}
(?i:str)                 {return STR;}
(?i:trap)                {return TRAP;}

%{ /* LC-3 Pseudo instructions */ %}
(?i:getc)                {return GETC;}
(?i:out)                 {return OUT;}
(?i:puts)                {return PUTS;}
(?i:in)                  {return IN;}
(?i:halt)                {return HALT;}

%{ /* 
LC-3 Condition flags 

According to the LC-3 manual, the condition flags are:
    N - Negative
    Z - Zero
    P - Positive

And they can be combined together to form flags, however the order matters.
This assembler will not enforce the order, technically making it a bit more lenient than the LC-3 manual.

*/ %}
(?i:br)                    { eat(); return BR; }
(?i:brp)                   { eat(); return BR_P; }
(?i:brz)                   { eat(); return BR_Z; }
(?i:brn)                   { eat(); return BR_N; }
(?i:br(pz|zp))             { eat(); return BR_PZ; }
(?i:br(pn|np))             { eat(); return BR_PN; }
(?i:br(zn|nz))             { eat(); return BR_ZN; }
(?i:br(pzn|pnz|zpn|znp|nzp|npz)) { eat(); return BR_PZN; }

%{ /* LC-3 Registers */ %}
(?i:r0)                  {return R0;}
(?i:r1)                  {return R1;}
(?i:r2)                  {return R2;}
(?i:r3)                  {return R3;}
(?i:r4)                  {return R4;}
(?i:r5)                  {return R5;}
(?i:r6)                  {return R6;}
(?i:r7)                  {return R7;}

%{ /* LC-3 Directives */ %}
(?i:.orig)               {return ORIG;}
(?i:.fill)               {return FILL;}
(?i:.blkw)               {return BLKW;}
(?i:.stringz)            {return STRINGZ;}
(?i:.end)                {return END;}

%{ /* LC-3 Comments */ %}
(?i:;[^\n]*)             { /* ignore comments */ }

%{ /* LC-3 Literals */ %}
[xX][0-9a-fA-F]+        {return HEX_LITERAL;}
#[0-9]+                   {return DECIMAL_LITERAL;}

%{ /* LC-3 Identifiers */ %}
identifier   {return IDENTIFIER;}

%{ /* LC-3 Whitespace */ %}
[ \t\n]                  { /* ignore whitespace */ }

%{ /* LC-3 Special characters */ %}
,                        { /* ignore commas */ }                    

%%

/**
 * This function initializes the lexer with the file to be read.
 * 
 * @param f The file to be read.
 */
void initLexer(FILE *f) {
  int length;
  fseek (f, 0, SEEK_END);
  length = ftell (f);
  fseek (f, 0, SEEK_SET);
  inputbuffer = malloc (length+1);
  inputbuffer[length]='\0';
  length = fread (inputbuffer, 1, length, f);
  fseek (f, 0, SEEK_SET);
  yyin = f;
}

void finalizeLexer() {
  free(inputbuffer);
  yylex_destroy();
}